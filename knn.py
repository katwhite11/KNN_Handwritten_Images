# -*- coding: utf-8 -*-
"""KNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a_Bm5vS1E26b-IOPVBak_3HkRrQ01ssQ
"""

from sklearn.datasets import load_digits
from sklearn.metrics import accuracy_score
import numpy as np
import matplotlib.pyplot as plt

"""#### Load Data"""

# loading data
digitsData = load_digits()

X = digitsData.data
y = digitsData.target

# Converts y to 2d array to be appended to X 
y = np.expand_dims(y, 1)

#X = digitsData.images.reshape((len(digitsData.images)), -1)

"""#### Shuffle Dataset"""

# Creates a new dataset with target appended at end for further classification
data = np.append(X, y, 1)

# Shuffles rows only
np.random.shuffle(data)

"""#### Train dataset"""

# Stores the total number of samples
total_sample = len(data)

# Sets our train/dev/test splits
train = data[:int(total_sample*0.70)]
dev = data[int(total_sample*0.70):int(total_sample*0.85)]
test = data[int(total_sample*0.85):]

"""#### Check Data Leaks"""

# Checks duplicate data between train/dev/test sets
def data_leaking_check(data1, data2):
  data_leaking = False
  for d1 in data1:
    for d2 in data2:
      if(np.array_equal(d1, d2)):
        data_leaking = True
        print("Find same sample: ")
        print(d1)
  if(not data_leaking):
    print("No Data Leaking!")

# Calls function to test data set: 
# data_leaking_check(train,test)

"""#### Assigns Features and Labels"""

# Assigns specific colums to features and labels (last column of the dataset)
def get_features_and_labels(data):
  features = data[:, :-1]
  labels = data[:, -1]
  return features, labels

# Sets train/dev/test X and y to the features and labels of each set
train_X, train_y = get_features_and_labels(train)
dev_X, dev_y = get_features_and_labels(dev)
test_X, test_y = get_features_and_labels(test)

"""#### Euclidean Distance"""

# Calculates Euclidean distance between two rows given to the function
def euclidean_distance(row1, row2):
  distance = 0.0
  for i in range(len(row1)-1):
    distance += (row1[i] - row2[i]) ** 2
  return np.sqrt(distance)

"""#### KNearestNeighbors"""

# Finds the nearest neighbors in a given set to the specific data
def get_neighbors(train_X, train_y, test_row, num_neighbors):
  distances = []

  # Gets all distances
  for index in range(len(train_X)):
    train_row = train_X[index]
    train_label = train_y[index]
    dist = euclidean_distance(train_row, test_row)
    distances.append((train_row, train_label, dist))

  # Sorts the distance list
  distances.sort(key=lambda i: i[2])

  output_neighbors = [] # features
  output_labels = [] #labels
  output_distances = [] #distances

  # Gets the K Nearest Neighbor and returns it
  for index in range(num_neighbors):
    output_neighbors.append(distances[index][0])
    output_labels.append(distances[index][1])
    output_distances.append(distances[index][2])

  return output_neighbors, output_labels, output_distances

"""#### Predictions"""

# Predicts the classification (hand written digit) by receiving training data
def prediction(train_X, train_y, test_row, num_neighbors):
  output_neighbors, output_labels, output_distances = get_neighbors(train_X, train_y, test_row, num_neighbors)
  label_cnt = np.bincount(output_labels)
  prediction = np.argmax(label_cnt)
  return prediction

"""#### K Value Testing"""

# k_list = list(range(1, 100, 2))
# performance = []

# for k in k_list:
#   pred_labels = []
#   for dev_data in dev_X:
#     pred = prediction(train_X, train_y, dev_data, k)
#     pred_labels.append(pred)
#   accuracy = accuracy_score(dev_y, pred_labels)
#   performance.append(accuracy)

# print(performance)

"""#### K Value Testing Plot"""

# # Plots figure
# plt.figure(figsize=(20, 6))
# plt.plot(k_list, performance)
# plt.plot(k_list, performance, "o")
# plt.xlabel("K Values")
# plt.ylabel("Accuracy")
# plt.title("Performance on Dev Set")

"""#### Accuracy Rating"""

k = 10
pred_labels = []
for test_data in test_X:
  pred = prediction(train_X, train_y, test_data, k)
  pred_labels.append(pred)
accuracy = accuracy_score(test_y, pred_labels)
print(accuracy)

print(test_y[109:119])
print(pred_labels[109:119])